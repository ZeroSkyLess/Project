#pragma config(Sensor, S1,     cS,             sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     uS,             sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     gS,             sensorEV3_Gyro)
#pragma config(Motor,  motorA,          lM,            tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          aM,            tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorD,          rM,            tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float floorDiameter = 30.5;
const float wheelDiameter = 6.6;
const float robotDiameter = 17;

const float wheelCircumference = wheelDiameter * 3.14159;
const float robotCircumference = robotDiameter * 3.14159;

const float degree = (((robotCircumference / 4) / wheelCircumference) * 360);
const float countsToTravel = ((floorDiameter / wheelCircumference) * 360) + 100;

const int x_size = 6;
const int y_size = 6;
int goalx;
int goaly;
int facing = 3;
// 0 = North
// 1 = East
// 2 = South
// 3 = West


//GLOBAL ARRAY representation of grid world using a 2-Dimensional array
//0  = open space
//1  = barrier
//2  = goal
//99 = robot
static int map[x_size][y_size] =
{
	{ 0, 99, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 0 },
	{ 0, 0, 1, 0, 0, 0 },
	{ 0, 0, 0, 0, 1, 0 },
	{ 1, 0, 0, 0, 0, 0 },
	{ 0, 0, 0, 0, 0, 1 },
};
		//map[4][0] = blue
		//map[2][2] = red
		//map[3][4] = yellow
		//map[5][5] = other


void displaymap()
{
	string map1 = "";
	for(int i = 0; i < x_size; i++)
	{
		map1 = "";
		for( int j = 0; j < y_size; j++)
		{
			map1 = map1 + map[i][j];
		}
		displayTextLine(i,map1);
	}
}


//move one block
void moveForward(int blocks)
{
	//convert number of blocks to encoder counts
	//encoder target for countsToTravel
	setMotorTarget(motorA, countsToTravel, 40);
	setMotorTarget(motorD, countsToTravel, 40);

	waitUntilMotorStop(motorA);
	waitUntilMotorStop(motorD);

	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);
}


//90 degree turn right  313.3928577
void right()
{
	resetGyro(S4);

	setMotorTarget(motorA, degree, 50);
	setMotorTarget(motorD, degree, -50);

	waitUntilMotorStop(motorA);
	waitUntilMotorStop(motorD);

	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);

	wait1Msec(1000);

	while (getGyroDegrees(S4) != 90)
	{
		if (getGyroDegrees(S4) == 90)
		{
			goto end1;
		}

		else if (getGyroDegrees(S4) > 90)
		{
			setMotorTarget(motorA, 5, -50);
			setMotorTarget(motorD, 5, 50);

			waitUntilMotorStop(motorA);
			waitUntilMotorStop(motorD);

			resetMotorEncoder(motorA);
			resetMotorEncoder(motorD);

		}

		else if (getGyroDegrees(S4) < 90)
		{
			setMotorTarget(motorA, 5, 50);
			setMotorTarget(motorD, 5, -50);

			waitUntilMotorStop(motorA);
			waitUntilMotorStop(motorD);

			resetMotorEncoder(motorA);
			resetMotorEncoder(motorD);

		}
	}
end1:;
}


//90 degree turn left   313.3928577
void left()
{
	resetGyro(S4);

	setMotorTarget(motorA, degree, -50);
	setMotorTarget(motorD, degree, 50);

	waitUntilMotorStop(motorA);
	waitUntilMotorStop(motorD);

	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);

	wait1Msec(1000);

	while (getGyroDegrees(S4) != -90)
	{

		if (getGyroDegrees(S4) > 90)
			goto end2;

		else if (getGyroDegrees(S4) < -90)
		{
			setMotorTarget(motorA, 5, 50);
			setMotorTarget(motorD, 5, -50);

			waitUntilMotorStop(motorA);
			waitUntilMotorStop(motorD);

			resetMotorEncoder(motorA);
			resetMotorEncoder(motorD);

		}

		else if (getGyroDegrees(S4) > -90)
		{
			setMotorTarget(motorA, 5, -50);
			setMotorTarget(motorD, 5, 50);

			waitUntilMotorStop(motorA);
			waitUntilMotorStop(motorD);

			resetMotorEncoder(motorA);
			resetMotorEncoder(motorD);

		}
	}
end2:;
}


//lift up good
void liftItem()   // nid change
{

	//forward
	setMotorTarget(motorA, 360, 50);
	setMotorTarget(motorD, 360, 50);

	waitUntilMotorStop(motorA);
	waitUntilMotorStop(motorD);

	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);

	wait1Msec(500);

	//lower down
	setMotorTarget(motorB, 200, 50);
	waitUntilMotorStop(motorB);
	resetMotorEncoder(motorB);

	wait1Msec(500);

	//check color

	while(getColorName(S1) == 0)
	{
		displayTextLine(1,"%d","No goods at loading bay, Debot will do action until goods is loaded");
	}

	wait1Msec(500);

	if (getColorName(S1) == 2)		//Blue
		map[4][0] = 2;

	if (getColorName(S1) == 5)		//Red
		map[2][2] = 2;

	if (getColorName(S1) == 7)		//Yellow
		map[3][4] = 2;

	if (getColorName(S1) != 2 && getColorName(S1) != 5 && getColorName(S1) != 7)		//other
		map[5][5] = 2;


	wait1Msec(500);


	//take item
	setMotorTarget(motorB, 1700, -50);
	waitUntilMotorStop(motorB);
	resetMotorEncoder(motorB);

	//back
	setMotorTarget(motorA, 360, -50);
	setMotorTarget(motorD, 360, -50);

	waitUntilMotorStop(motorA);
	waitUntilMotorStop(motorD);

	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);

}


//drop good
void dropItem()  // nid change
{
	//forward
	setMotorTarget(motorA, 360, 50);
	setMotorTarget(motorD, 360, 50);

	waitUntilMotorStop(motorA);
	waitUntilMotorStop(motorD);

	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);

	wait1Msec(500);

	//drop item
	setMotorTarget(motorB, 1500, 50);
	waitUntilMotorStop(motorB);
	resetMotorEncoder(motorB);

	wait1Msec(500);

	//back
	setMotorTarget(motorA, 360, -50);
	setMotorTarget(motorD, 360, -50);

	waitUntilMotorStop(motorA);
	waitUntilMotorStop(motorD);

	resetMotorEncoder(motorA);
	resetMotorEncoder(motorD);
}


//FUNCTION wavefront algorithm to find most efficient path to goal
void WavefrontSearch()
{
	int goal_x, goal_y;
	bool foundWave = true;
	int currentWave = 2; //Looking for goal first

	while (foundWave == true)
	{
		foundWave = false;
		for (int x = 0; x < x_size; x++)
		{
			for (int y = 0; y < y_size; y++)
			{
				if (map[x][y] == currentWave)
				{
					foundWave = true;
					goal_x = x;
					goal_y = y;

					if (goal_x > 0) //This code checks the array bounds heading North
						if (map[goal_x - 1][goal_y] == 0)  //This code checks the North direction
							map[goal_x - 1][goal_y] = currentWave + 1;

					if (goal_x < (x_size - 1)) //This code checks the array bounds heading South
						if (map[goal_x + 1][goal_y] == 0)//This code checks the South direction
							map[goal_x + 1][goal_y] = currentWave + 1;

					if (goal_y > 0)//This code checks the array bounds heading West
						if (map[goal_x][goal_y - 1] == 0) //This code checks the West direction
							map[goal_x][goal_y - 1] = currentWave + 1;

					if (goal_y < (y_size - 1))//This code checks the array bounds heading East
						if (map[goal_x][goal_y + 1] == 0) //This code checks the East direction
							map[goal_x][goal_y + 1] = currentWave + 1;
				}
			}
		}
		currentWave++;
	}
}


void NavigateToGoal()
{
	//Store our Robots Current Position
	int robot_x, robot_y;

	//First - Find Goal and Target Locations
	for (int x = 0; x < x_size; x++)
	{
		for (int y = 0; y < y_size; y++)
		{
			if (map[x][y] == 99)
			{
				robot_x = x;
				robot_y = y;
			}
		}
	}

	//Found Goal and Target, start deciding our next path
	int current_x = robot_x;
	int current_y = robot_y;
	int current_facing = facing;
	int next_Direction;
	int current_low = 99;

	while (current_low > 2)
	{
		current_low = 99; //Every time, reset to highest number (robot)
		next_Direction = current_facing;
		int Next_X = 0;
		int Next_Y = 0;

		// 0 = North
		// 1 = East
		// 2 = South
		// 3 = West

		//Check Array Bounds North
		if (current_x > 0)
			if (map[current_x - 1][current_y] < current_low && map[current_x - 1][current_y] != 1) //Is current space occupied?
			{
				current_low = map[current_x - 1][current_y];  //Set next number
				next_Direction = 0; //Set Next Direction as Notrh
				Next_X = current_x - 1;
				Next_Y = current_y;
			}

		//Check Array Bounds South
		if (current_x < (x_size - 1))
			if (map[current_x + 1][current_y] < current_low && map[current_x + 1][current_y] != 1) //Is current space occupied?
			{
				current_low = map[current_x + 1][current_y];  //Set next number
				next_Direction = 2; //Set Next Direction as South
				Next_X = current_x + 1;
				Next_Y = current_y;
			}

		//Check Array Bounds West
		if (current_y > 0)
			if (map[current_x][current_y - 1] < current_low && map[current_x][current_y - 1] != 1)
			{
				current_low = map[current_x][current_y - 1];  //Set next number
				next_Direction = 3; //Set Next Direction as West
				Next_X = current_x;
				Next_Y = current_y - 1;
			}

		//Check Array Bounds East
		if (current_y < (y_size - 1))
			if (map[current_x][current_y + 1] < current_low && map[current_x][current_y + 1] != 1) //Is current space occupied?
			{
				current_low = map[current_x][current_y + 1];  //Set next number
				next_Direction = 1; //Set Next Direction as East
				Next_X = current_x;
				Next_Y = current_y + 1;
			}

		//Track the robot's heading
		while (current_facing != next_Direction)
		{
			if (current_facing > next_Direction)
			{
				left();
				current_facing--;
			}
			else if (current_facing < next_Direction)
			{
				right();
				current_facing++;
			}
		}

		//Okay - We know the number we're heading for, the direction and the coordinates.

		if (map[Next_X][Next_Y] != 2)
		{
			wait1Msec(500);

			// check obstacle in front
			if (getUSDistance(S2) <= 25 && getUSDistance(S2) >= 10) //need to adjust
			{
				for (int i = 0; i < x_size; i++)
				{
					for (int j = 0; j < y_size; j++)
					{
						if (map[i][j] > 2)
						{
							map[i][j] = 0;
						}
					}
				}

				if (current_facing == 0)
					map[current_x - 1][current_y] = 1;

				else if (current_facing == 1)
					map[current_x][current_y + 1] = 1;

				else if (current_facing == 2)
					map[current_x + 1][current_y] = 1;

				else if (current_facing == 3)
					map[current_x][current_y - 1] = 1;

				map[current_x][current_y] = 99;
				WavefrontSearch();
			}

			else
			{
				map[current_x][current_y] = 88;
				current_x = Next_X;
				current_y = Next_Y;
				moveForward(1);
			}
		}

		else
		{
			if(Next_X == 0 && Next_Y == 0)
			{
			}

			else
				dropItem();

			goalx = current_x;
			goaly = current_y;
			facing = current_facing;
			goto end4;

		}

		goalx = current_x;
		goaly = current_y;
		facing = current_facing;
		current_low = map[current_x][current_y];
		map[current_x][current_y] = 99;

	}
end4:;

	for (int i = 0; i < x_size; i++)
	{
		for (int j = 0; j < y_size; j++)
		{
			if (map[i][j] > 2)
			{
				map[i][j] = 0;
			}

			if (map[i][j] == 2)
			{
				map[i][j] = 1;
			}
		}
	}

	map[goalx][goaly] = 99;
}

void resetmap()
{
	map[0][0] = 2;
	WavefrontSearch();
	NavigateToGoal();
}


task main()
{
	while(true)
	{
		while( getUSDistance(S2) >= 10 && getUSDistance(S2) < 15)
		{
			displayTextLine(1,"Taking good");
			liftItem();
			displayTextLine(1,"Going to goal");
			WavefrontSearch();
			NavigateToGoal();
			displayTextLine(1,"Going to loading bay");
			resetmap();
		}

		displayTextLine(1,"Waiting for loading good");
	}
}



// (circumference of 90 degree / circumference of wheel) * 90
// (distance to go / circumference of wheel) * 360
